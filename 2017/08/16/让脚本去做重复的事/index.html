<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 让脚本去做重复的事 · Lcrnice</title><meta name="description" content="让脚本去做重复的事 - Lcrnice"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/2597892552" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/lcrnice" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">让脚本去做重复的事</h1><div class="post-time">2017年8月16日</div><div class="post-content"><p><img src="http://7xt6wu.com1.z0.glb.clouddn.com/ShellScript.png" alt="overview"></p>
<p>日常的生活和工作中，每个人都不得不做一些重复的事情。当下火热的 <a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD" target="_blank" rel="external">AI</a> 从某种意义上讲，就是让机器代替人去处理一些情况复杂且重复性高的事情，比如自动驾驶、人脸识别等。对技术人员来说，工作中同样有很多重复性的工作，这些事情一旦掌握之后，不断重复就变得毫无意义。<br>本文将结合切身的需求，展现如何运用基本的 <a href="https://zh.wikipedia.org/wiki/Shell%E8%84%9A%E6%9C%AC" target="_blank" rel="external">Shell脚本</a>，来解决工作中出现的一些实际问题。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p><a href="https://github.com/ksvc/KSYLive_iOS" target="_blank" rel="external">金山云</a>的编解码技术很成熟，我想使用金山的功能，但不想将其打包为 .framework，而是直接在 Xcode 工程中引入一些 .a 文件。<br><img src="http://7xt6wu.com1.z0.glb.clouddn.com/blog:shell_aFiles.png" alt="aFiles"><br>在导入了对应的 .a 文件和源码之后，编译失败，提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols for architecture arm64:</span><br><span class="line">  &quot;_OBJC_CLASS_$_KSYOfflineAuth&quot;, referenced from:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从错误提示上看，是我们源码的功能中使用了 <code>KSYOfflineAuth</code> 的类，但是没有导入对应的实现类或.a文件。  </p>
<h2 id="要做的事"><a href="#要做的事" class="headerlink" title="要做的事"></a>要做的事</h2><p>当前已经明确了缺少实现代码的类名，而从 .a 文件的名字来看，根本无法区分出该类属于哪个 .a 文件。所以，需要使用 <code>ar</code> 命令，拆分出 .a 文件中所包含的所有 <code>.o</code> 文件。  </p>
<p><code>ar</code> 命令操作的 .a 库只能是 <code>Non-fat</code> 的文件，所以需要先使用 <code>lipo</code> 命令，为 <em>Fat</em> 的 .a 库 <em>瘦身</em>。  </p>
<p>拷贝 .a 文件所在文件夹 <strong>libs</strong> 到指定目录，并进入 libs，首先拆分 <em>libksystreamerbase.a</em> 来找一找目标类  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看 libksystreamerbase.a 的信息</span><br><span class="line">$ lipo libksystreamerbase.a -info</span><br><span class="line"></span><br><span class="line">Architectures in the fat file: libksystreamerbase.a are: armv7 i386 x86_64 arm64</span><br></pre></td></tr></table></figure>
<p>从输出中可以看出 libksystreamerbase.a 是一个 <strong>fat file</strong>，并且包含我使用 iPhone 6s Plus 调试时所需要的 <em>arm64 指令集</em>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将 libksystreamerbase.a 瘦身为只有 arm64 指令集的新文件 libksystreamerbase_arm64.a</span><br><span class="line">$ lipo libksystreamerbase.a -thin arm64 -output libksystreamerbase_arm64.a</span><br></pre></td></tr></table></figure>
<p>此时已经准备好了单一指令集的 <strong>Non-fat</strong> libksystreamerbase_arm64.a 文件，在拆分之前，最好为 libksystreamerbase_arm64.a 文件创建一个文件夹，来存放才分出来的的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir libksystreamerbase_dir</span><br><span class="line">cd libksystreamerbase_dir</span><br></pre></td></tr></table></figure>
<p>执行 ar 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ar -x ../libksystreamerbase_arm64.a</span><br><span class="line">$ ls</span><br></pre></td></tr></table></figure>
<p>此时，<em>libksystreamerbase_dir</em> 文件夹下存放的，就应该是 libksystreamerbase.a 中包含的 <em>.o</em> 文件了，可以查看是否存在我们在寻找的 <code>KSYOfflineAuth</code></p>
<p>事实证明，我们的运气并不好，libksystreamerbase.a 没有要找的 .o 文件。那是不是说极限情况下，我需要拆分所有的 .a 库才能找到哪个库包含 <code>KSYOfflineAuth</code> ？</p>
<h2 id="善用Shell脚本"><a href="#善用Shell脚本" class="headerlink" title="善用Shell脚本"></a>善用Shell脚本</h2><p>直接怼脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#! bin/bash</span><br><span class="line"></span><br><span class="line">THIN_LIBS=thinLibs</span><br><span class="line">O_FILES=oFiles</span><br><span class="line">function openLib() &#123;</span><br><span class="line">    if [ $# -lt 1 ];then</span><br><span class="line">        echo &apos;需要输入thin文件.&apos;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    THINDIR=$1_thin_dir</span><br><span class="line"></span><br><span class="line">    mkdir -p $THIN_LIBS</span><br><span class="line">    mkdir -p $O_FILES</span><br><span class="line"></span><br><span class="line">    if [ $1 ]; then</span><br><span class="line">        cd $THIN_LIBS</span><br><span class="line">        lipo ../$1 -thin arm64 -output 64_$1</span><br><span class="line">        cd ../$O_FILES</span><br><span class="line">        mkdir -p $THINDIR</span><br><span class="line">        cd $THINDIR</span><br><span class="line">        ar -x ../../$THIN_LIBS/64_$1</span><br><span class="line">        cd ../../</span><br><span class="line">        echo &quot;解压了 $1 &quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LIB_DIR=`pwd`</span><br><span class="line"></span><br><span class="line">for file in `ls`</span><br><span class="line">do</span><br><span class="line">    echo $file</span><br><span class="line">    if [ $file = &apos;makeFiles.sh&apos; ];then</span><br><span class="line">        echo &apos;不操作本文件&apos;</span><br><span class="line">    else</span><br><span class="line">        openLib $file</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>这只是一个及其简略的脚本，大体做了一下几件事情：  </p>
<ul>
<li>定义<em>openLib()</em>方法，方法内为所处理的 .a 文件创建保存 .o 文件的文件夹，并<em>瘦身</em>、<em>拆分</em>目标 .a 文件</li>
<li>获取当前路径，并遍历当前目录下所有文件名</li>
<li>每获取到一个文件名，都去调用定义好的<em>openLib()</em>方法</li>
</ul>
<p>我将 .sh 命名为 <em>makeFiles.sh</em>，并在脚本中做了判断，不处理当前 .sh 文件。使用时，只需要将 makeFiles.sh 放到 libs 目录下，运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh makeFiles.sh</span><br></pre></td></tr></table></figure>
<p>控制台会持续输出日志，并很快执行完成。此时 libs 目录下会生成新创建的 <code>oFiles</code> 和 <code>thinLibs</code> 目录，内部分别存放着所有原始 .a 文件拆分后的 .o 文件和单一指令集的 .a 文件。</p>
<p>在当前 libs 目录下，使用 <code>find</code> 命令，模糊搜索之前缺失类的名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name &quot;*KSYOfflineAuth*&quot;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libksybase.a_thin_dir/KSYOfflineAuth.o</span><br></pre></td></tr></table></figure>
<p>Found it!!</p>
<p>搜索结果显示，目标文件在 <em>libksybase.a_thin_dir</em> 目录下，<em>libksybase.a_thin_dir</em> 是 <em>libksybase.a</em> 瘦身后拆分出来的内容目录，所以，我们只需要在工程中导入 <em>libksybase.a</em> 即可。</p>
<p>如上 Shell 脚本中，对于没有 Shell 脚本基础的人来说，只需要明确几点就很容易理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. ` `的意思是获取其中命令的执行结果</span><br><span class="line">2. &apos; &apos;和&quot; &quot;的内容是一个字符串</span><br><span class="line">3. 使用 function 来定义函数，函数调用直接使用函数名</span><br><span class="line">4. if 判断右侧需要有 then，结尾需要有对应的 fi</span><br><span class="line">5. Shell脚本中 $1 代表调用时传入的第一个参数</span><br></pre></td></tr></table></figure>
<p>使用 Shell 脚本只需要学习一些很简单的基础概念，结合终端命令就可以运用于很多实际的场景中，这也是相比于 GUI 的 git 管理等工具而言，我更喜欢终端的原因之一。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Shell脚本可以执行很多固定规则的事情，比如上文对 .a 文件的拆分，我可以一个一个进行操作，但是既耗时又无聊。使用Shell脚本可以在工作中为我们应付很多重复枯燥的事情，比如打包ipa、修改配置文件、自动化部署等等，灵活运用才是王道。</p>
<p>祝玩的开心~</p>
</div></article></div></section><footer><div class="paginator"><a href="/2017/07/12/set-up-vpn/" class="next">下一篇</a></div><div class="copyright"> <p>感兴趣可以关注<a href="https://github.com/Lcrnice">我的GitHub</a> 或关注微博<a href="http://weibo.com/u/2597892552/">@Lcrnice丶</a></p><p>© 2015 - 2017 <a href="http://lcrnice.github.com">Lcrnice</a> · Powered by Hexo</p></div></footer></div><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>